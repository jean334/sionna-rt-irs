{
	"nodes":[
		{"id":"ba5f3fce22666bea","x":-260,"y":200,"width":400,"height":480,"type":"text","text":"`__call__`\n\n- The prototype is unchanged, since the IRS is now a property of the `Scene` class.\n    \n- Compute and format the precoding vector of the transmitters; this will be used to build a `synthetic_array` and apply it to the `e_field`.\n    \n- Build Mitsuba rectangles at the RIS position and orientation, and assign them unique IDs. This is equivalent to creating a new scene that contains only the IRS.\n    \n- Initialize the `RadioMap`.\n    \n- Enter the `shoot_and_bounce` method (the core of the ray tracing logic)."},
		{"id":"d63d02b6a0926e44","x":-150,"y":40,"width":180,"height":60,"color":"1","type":"text","text":"`RadioMapSolver`"},
		{"id":"54601ad5a4fd58fc","x":220,"y":120,"width":400,"height":560,"type":"text","text":"`shoot_and_bounce`\n\n- Spawn rays using a Fibonacci lattice to determine ray directions at the transmitter positions. This forms the initial bulk of rays.\n    \n- Call `_synthetic_array_weighting` to compute the weighting applied to the electric field, synthetically modeling the transmitter array.\n    \n- Initialize the `active` ray mask, `ray_tube_length`, and `solid_angle`. Rays are modeled as tubes rather than lines; the sphere’s solid angle ($4\\pi$) is divided among the number of rays.\n    \n- Initialize `e_fields`.\n    \n- Enter the propagation loop, which continues until no active rays remain or the `max_depth` is reached."},
		{"id":"26345a41180381f7","x":720,"y":-49,"width":400,"height":979,"type":"text","text":"`shoot_and_bounce loop`\n\n- Compute intersections with the `scene`.\n    \n- Compute intersections with the `measurement_plane` (the plane representing the `radio_map`).\n    \n- Compute intersections with the `RIS`.\n    \n- Compute the masks `hit_scene` and `hit_ris` to determine which rays hit which element first. The `measurement_plane` is not a physical element — rays do not bounce on it. It is only used to record whether it was hit for building the `radio_map`.\n    \n- Update the `radio_map`.\n    \n- Manage interactions between scene elements and rays. This step evaluates the `radio material` (concrete, glass, etc.) and updates the electric field accordingly. The interaction type of the rays with the scene object is then determined (specular reflection, diffuse reflection, refraction).\n    \n- Spawn new rays at the intersection point between the scene and the previous ray, in the appropriate direction.\n    \n- Manage interactions between the IRS and rays via `_compute_ris_reflected_field`. This method updates the `e_field` accordingly.\n    \n- Repeat the cycle until `max_depth` or other termination thresholds are reached"}
	],
	"edges":[
		{"id":"adea1ee033bfe207","fromNode":"d63d02b6a0926e44","fromSide":"bottom","toNode":"ba5f3fce22666bea","toSide":"top"},
		{"id":"6590e49ba42dbfd2","fromNode":"ba5f3fce22666bea","fromSide":"bottom","toNode":"54601ad5a4fd58fc","toSide":"top"},
		{"id":"0eac96d29378a870","fromNode":"54601ad5a4fd58fc","fromSide":"bottom","toNode":"26345a41180381f7","toSide":"top"}
	]
}